;; Analyzed by ClojureScript 0.0-3308
{:use-macros {with-monad cats.core, mlet cats.core}, :excludes #{when unless filter sequence}, :name cats.core, :imports nil, :requires {p cats.protocols, cats.protocols cats.protocols}, :uses nil, :defs {pure {:protocol-inline nil, :meta {:file "/home/user/projects/imperative-nodejs/playground/out/cats/core.cljs", :line 85, :column 7, :end-line 85, :end-column 11, :arglists (quote ([v] [ctx v])), :doc "Given any value v, return it wrapped in\n  default/effect free context.\n\n  This is multiarity function that with arity pure/1\n  it uses the dynamic scope to resolve the current\n  context. With `pure/2`, you can force a specific context\n  value.\n\n  Example:\n\n      (with-monad either/either-monad\n        (pure 1)\n      ;; => #<Right [1]>\n  ", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([v] [ctx v]), :arglists ([v] [ctx v]), :arglists-meta (nil nil)}}, :name cats.core/pure, :variadic false, :file "out/cats/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([v] [ctx v]), :arglists ([v] [ctx v]), :arglists-meta (nil nil)}, :method-params ([v] [ctx v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 85, :end-line 85, :max-fixed-arity 2, :fn-var true, :arglists ([v] [ctx v]), :doc "Given any value v, return it wrapped in\n  default/effect free context.\n\n  This is multiarity function that with arity pure/1\n  it uses the dynamic scope to resolve the current\n  context. With `pure/2`, you can force a specific context\n  value.\n\n  Example:\n\n      (with-monad either/either-monad\n        (pure 1)\n      ;; => #<Right [1]>\n  "}, get-current-context {:no-doc true, :protocol-inline nil, :meta {:file "/home/user/projects/imperative-nodejs/playground/out/cats/core.cljs", :line 58, :column 3, :end-line 58, :end-column 22, :no-doc true, :arglists (quote ([] [default])), :doc "Get current context or obtain it from\n  the provided instance.", :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [default]), :arglists ([] [default]), :arglists-meta (nil nil)}}, :name cats.core/get-current-context, :variadic false, :file "out/cats/core.cljs", :end-column 22, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [default]), :arglists ([] [default]), :arglists-meta (nil nil)}, :method-params ([] [default]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 57, :end-line 58, :max-fixed-arity 1, :fn-var true, :arglists ([] [default]), :doc "Get current context or obtain it from\n  the provided instance."}, fapply {:protocol-inline nil, :meta {:file "/home/user/projects/imperative-nodejs/playground/out/cats/core.cljs", :line 163, :column 7, :end-line 163, :end-column 13, :arglists (quote ([af av])), :doc "Given function inside af's conext and value inside\n  av's context, applies the function to value and return\n  a result wrapped in context of same type of av context."}, :name cats.core/fapply, :variadic false, :file "out/cats/core.cljs", :end-column 13, :method-params ([af av]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 163, :end-line 163, :max-fixed-arity 2, :fn-var true, :arglists (quote ([af av])), :doc "Given function inside af's conext and value inside\n  av's context, applies the function to value and return\n  a result wrapped in context of same type of av context."}, <*> {:protocol-inline nil, :meta {:file "/home/user/projects/imperative-nodejs/playground/out/cats/core.cljs", :line 356, :column 7, :end-line 356, :end-column 10, :arglists (quote ([af av] [af av & avs])), :doc "Performs a Haskell-style left-associative fapply.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([af av]), :arglists ([af av] [af av & avs]), :arglists-meta (nil nil)}}, :name cats.core/<*>, :variadic true, :file "out/cats/core.cljs", :end-column 10, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([af av]), :arglists ([af av] [af av & avs]), :arglists-meta (nil nil)}, :method-params ([af av]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 356, :end-line 356, :max-fixed-arity 2, :fn-var true, :arglists ([af av] [af av & avs]), :doc "Performs a Haskell-style left-associative fapply."}, guard {:protocol-inline nil, :meta {:file "/home/user/projects/imperative-nodejs/playground/out/cats/core.cljs", :line 144, :column 7, :end-line 144, :end-column 12, :arglists (quote ([b]))}, :name cats.core/guard, :variadic false, :file "out/cats/core.cljs", :end-column 12, :method-params ([b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 144, :end-line 144, :max-fixed-arity 1, :fn-var true, :arglists (quote ([b]))}, join {:protocol-inline nil, :meta {:file "/home/user/projects/imperative-nodejs/playground/out/cats/core.cljs", :line 150, :column 7, :end-line 150, :end-column 11, :arglists (quote ([mv])), :doc "Remove one level of monadic structure.\n  This is same as that `(bind mv identity)`"}, :name cats.core/join, :variadic false, :file "out/cats/core.cljs", :end-column 11, :method-params ([mv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 150, :end-line 150, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mv])), :doc "Remove one level of monadic structure.\n  This is same as that `(bind mv identity)`"}, *context* {:name cats.core/*context*, :file "out/cats/core.cljs", :line 37, :column 1, :end-line 39, :end-column 12, :dynamic true, :no-doc true, :meta {:file "/home/user/projects/imperative-nodejs/playground/out/cats/core.cljs", :line 39, :column 3, :end-line 39, :end-column 12, :dynamic true, :no-doc true}}, bind {:protocol-inline nil, :meta {:file "/home/user/projects/imperative-nodejs/playground/out/cats/core.cljs", :line 109, :column 7, :end-line 109, :end-column 11, :arglists (quote ([mv f])), :doc "Given a value inside monadic context `mv` and any function,\n  applies a function to value of mv.\n\n      (bind (either/right 1) (fn [v]\n                               (return (inc v))))\n      ;; => #<Right [2]>\n\n  For convenience, you may prefer use a `mlet` macro\n  that add a beautiful, let like syntax for\n  compose operations with `bind` function."}, :name cats.core/bind, :variadic false, :file "out/cats/core.cljs", :end-column 11, :method-params ([mv f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 109, :end-line 109, :max-fixed-arity 2, :fn-var true, :arglists (quote ([mv f])), :doc "Given a value inside monadic context `mv` and any function,\n  applies a function to value of mv.\n\n      (bind (either/right 1) (fn [v]\n                               (return (inc v))))\n      ;; => #<Right [2]>\n\n  For convenience, you may prefer use a `mlet` macro\n  that add a beautiful, let like syntax for\n  compose operations with `bind` function."}, <$> {:protocol-inline nil, :meta {:file "/home/user/projects/imperative-nodejs/playground/out/cats/core.cljs", :line 348, :column 7, :end-line 348, :end-column 10, :arglists (quote ([f] [f fv])), :doc "Alias of fmap.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f fv]), :arglists ([f] [f fv]), :arglists-meta (nil nil)}}, :name cats.core/<$>, :variadic false, :file "out/cats/core.cljs", :end-column 10, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f fv]), :arglists ([f] [f fv]), :arglists-meta (nil nil)}, :method-params ([f] [f fv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 348, :end-line 348, :max-fixed-arity 2, :fn-var true, :arglists ([f] [f fv]), :doc "Alias of fmap."}, <=< {:protocol-inline nil, :meta {:file "/home/user/projects/imperative-nodejs/playground/out/cats/core.cljs", :line 399, :column 7, :end-line 399, :end-column 10, :arglists (quote ([mg mf x])), :doc "Right-to-left composition of monads.\n  Same as `>=>` with its first two arguments flipped."}, :name cats.core/<=<, :variadic false, :file "out/cats/core.cljs", :end-column 10, :method-params ([mg mf x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 399, :end-line 399, :max-fixed-arity 3, :fn-var true, :arglists (quote ([mg mf x])), :doc "Right-to-left composition of monads.\n  Same as `>=>` with its first two arguments flipped."}, lift {:protocol-inline nil, :meta {:file "/home/user/projects/imperative-nodejs/playground/out/cats/core.cljs", :line 185, :column 7, :end-line 185, :end-column 11, :arglists (quote ([mv] [m mv])), :doc "Lift a value from the inner monad of a monad transformer\n  into a value of the monad transformer.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([mv] [m mv]), :arglists ([mv] [m mv]), :arglists-meta (nil nil)}}, :name cats.core/lift, :variadic false, :file "out/cats/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([mv] [m mv]), :arglists ([mv] [m mv]), :arglists-meta (nil nil)}, :method-params ([mv] [m mv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 185, :end-line 185, :max-fixed-arity 2, :fn-var true, :arglists ([mv] [m mv]), :doc "Lift a value from the inner monad of a monad transformer\n  into a value of the monad transformer."}, when {:protocol-inline nil, :meta {:file "/home/user/projects/imperative-nodejs/playground/out/cats/core.cljs", :line 170, :column 7, :end-line 170, :end-column 11, :arglists (quote ([b mv] [ctx b mv])), :doc "If the expression is true, returns the monadic value.\n  Otherwise, yields nil in a monadic context.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([b mv] [ctx b mv]), :arglists ([b mv] [ctx b mv]), :arglists-meta (nil nil)}}, :name cats.core/when, :variadic false, :file "out/cats/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([b mv] [ctx b mv]), :arglists ([b mv] [ctx b mv]), :arglists-meta (nil nil)}, :method-params ([b mv] [ctx b mv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 170, :end-line 170, :max-fixed-arity 3, :fn-var true, :arglists ([b mv] [ctx b mv]), :doc "If the expression is true, returns the monadic value.\n  Otherwise, yields nil in a monadic context."}, >>= {:protocol-inline nil, :meta {:file "/home/user/projects/imperative-nodejs/playground/out/cats/core.cljs", :line 363, :column 7, :end-line 363, :end-column 10, :arglists (quote ([mv f] [mv f & fs])), :doc "Performs a Haskell-style left-associative\n  bind.\n\n  Let see it in action:\n\n      (>>= (just 1) (comp just inc) (comp just inc))\n      ;; => #<Just [3]>\n  ", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([mv f]), :arglists ([mv f] [mv f & fs]), :arglists-meta (nil nil)}}, :name cats.core/>>=, :variadic true, :file "out/cats/core.cljs", :end-column 10, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([mv f]), :arglists ([mv f] [mv f & fs]), :arglists-meta (nil nil)}, :method-params ([mv f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 363, :end-line 363, :max-fixed-arity 2, :fn-var true, :arglists ([mv f] [mv f & fs]), :doc "Performs a Haskell-style left-associative\n  bind.\n\n  Let see it in action:\n\n      (>>= (just 1) (comp just inc) (comp just inc))\n      ;; => #<Just [3]>\n  "}, mzero {:protocol-inline nil, :meta {:file "/home/user/projects/imperative-nodejs/playground/out/cats/core.cljs", :line 133, :column 7, :end-line 133, :end-column 12, :arglists (quote ([]))}, :name cats.core/mzero, :variadic false, :file "out/cats/core.cljs", :end-column 12, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 133, :end-line 133, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, return {:protocol-inline nil, :meta {:file "/home/user/projects/imperative-nodejs/playground/out/cats/core.cljs", :line 103, :column 7, :end-line 103, :end-column 13, :arglists (quote ([v] [ctx v])), :doc "This is a monad version of pure and it works\n  identically to it.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([v] [ctx v]), :arglists ([v] [ctx v]), :arglists-meta (nil nil)}}, :name cats.core/return, :variadic false, :file "out/cats/core.cljs", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([v] [ctx v]), :arglists ([v] [ctx v]), :arglists-meta (nil nil)}, :method-params ([v] [ctx v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 103, :end-line 103, :max-fixed-arity 2, :fn-var true, :arglists ([v] [ctx v]), :doc "This is a monad version of pure and it works\n  identically to it."}, mapseq {:protocol-inline nil, :meta {:file "/home/user/projects/imperative-nodejs/playground/out/cats/core.cljs", :line 282, :column 7, :end-line 282, :end-column 13, :arglists (quote ([mf coll])), :doc "Given a function that takes a value and puts it into a\n   monadic context, map it into the given collection\n   calling sequence on the results.\n\n       (require '[cats.monad.maybe :as maybe])\n       (require '[cats.core :as m])\n\n       (m/mapseq maybe/just [2 3])\n       ;=> <Just [[2 3]]>\n\n       (m/mapseq (fn [v]\n                    (if (odd? v)\n                      (maybe/just v)\n                      (maybe/nothing)))\n                   [1 2])\n       ;=> <Nothing>\n  "}, :name cats.core/mapseq, :variadic false, :file "out/cats/core.cljs", :end-column 13, :method-params ([mf coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 282, :end-line 282, :max-fixed-arity 2, :fn-var true, :arglists (quote ([mf coll])), :doc "Given a function that takes a value and puts it into a\n   monadic context, map it into the given collection\n   calling sequence on the results.\n\n       (require '[cats.monad.maybe :as maybe])\n       (require '[cats.core :as m])\n\n       (m/mapseq maybe/just [2 3])\n       ;=> <Just [[2 3]]>\n\n       (m/mapseq (fn [v]\n                    (if (odd? v)\n                      (maybe/just v)\n                      (maybe/nothing)))\n                   [1 2])\n       ;=> <Nothing>\n  "}, mplus {:protocol-inline nil, :meta {:file "/home/user/projects/imperative-nodejs/playground/out/cats/core.cljs", :line 138, :column 7, :end-line 138, :end-column 12, :arglists (quote ([& mvs])), :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(mvs)], :arglists ([& mvs]), :arglists-meta (nil)}}, :name cats.core/mplus, :variadic true, :file "out/cats/core.cljs", :end-column 12, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(mvs)], :arglists ([& mvs]), :arglists-meta (nil)}, :method-params [(mvs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 138, :end-line 138, :max-fixed-arity 0, :fn-var true, :arglists ([& mvs])}, >> {:protocol-inline nil, :meta {:file "/home/user/projects/imperative-nodejs/playground/out/cats/core.cljs", :line 377, :column 7, :end-line 377, :end-column 9, :arglists (quote ([mv mv'] [mv mv' & mvs])), :doc "Performs a Haskell-style left-associative bind,\n  ignoring the values produced by the monad computations.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([mv mv']), :arglists ([mv mv'] [mv mv' & mvs]), :arglists-meta (nil nil)}}, :name cats.core/>>, :variadic true, :file "out/cats/core.cljs", :end-column 9, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([mv mv']), :arglists ([mv mv'] [mv mv' & mvs]), :arglists-meta (nil nil)}, :method-params ([mv mv']), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 377, :end-line 377, :max-fixed-arity 2, :fn-var true, :arglists ([mv mv'] [mv mv' & mvs]), :doc "Performs a Haskell-style left-associative bind,\n  ignoring the values produced by the monad computations."}, unless {:protocol-inline nil, :meta {:file "/home/user/projects/imperative-nodejs/playground/out/cats/core.cljs", :line 178, :column 7, :end-line 178, :end-column 13, :arglists (quote ([b mv])), :doc "If the expression is false, returns the monadic value.\n  Otherwise, yields nil in a monadic context."}, :name cats.core/unless, :variadic false, :file "out/cats/core.cljs", :end-column 13, :method-params ([b mv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 178, :end-line 178, :max-fixed-arity 2, :fn-var true, :arglists (quote ([b mv])), :doc "If the expression is false, returns the monadic value.\n  Otherwise, yields nil in a monadic context."}, forseq {:protocol-inline nil, :meta {:file "/home/user/projects/imperative-nodejs/playground/out/cats/core.cljs", :line 303, :column 7, :end-line 303, :end-column 13, :arglists (quote ([vs mf])), :doc "Same as mapseq but with the arguments in reverse order.\n\n  Let se a little example:\n\n      (m/forseq [2 3] maybe/just)\n      ;; => <Just [[2 3]]>\n\n  Yet an other example that fails:\n\n      (m/forseq [1 2]\n                (fn [v]\n                  (if (odd? v)\n                    (maybe/just v)\n                    (maybe/nothing))))\n      ;; => <Nothing>\n  "}, :name cats.core/forseq, :variadic false, :file "out/cats/core.cljs", :end-column 13, :method-params ([vs mf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 303, :end-line 303, :max-fixed-arity 2, :fn-var true, :arglists (quote ([vs mf])), :doc "Same as mapseq but with the arguments in reverse order.\n\n  Let se a little example:\n\n      (m/forseq [2 3] maybe/just)\n      ;; => <Just [[2 3]]>\n\n  Yet an other example that fails:\n\n      (m/forseq [1 2]\n                (fn [v]\n                  (if (odd? v)\n                    (maybe/just v)\n                    (maybe/nothing))))\n      ;; => <Nothing>\n  "}, =<< {:protocol-inline nil, :meta {:file "/home/user/projects/imperative-nodejs/playground/out/cats/core.cljs", :line 385, :column 7, :end-line 385, :end-column 10, :arglists (quote ([f mv])), :doc "Same as the two argument version of `>>=` but with the\n  arguments interchanged."}, :name cats.core/=<<, :variadic false, :file "out/cats/core.cljs", :end-column 10, :method-params ([f mv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 385, :end-line 385, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f mv])), :doc "Same as the two argument version of `>>=` but with the\n  arguments interchanged."}, >=> {:protocol-inline nil, :meta {:file "/home/user/projects/imperative-nodejs/playground/out/cats/core.cljs", :line 391, :column 7, :end-line 391, :end-column 10, :arglists (quote ([mf mg x])), :doc "Left-to-right composition of monads."}, :name cats.core/>=>, :variadic false, :file "out/cats/core.cljs", :end-column 10, :method-params ([mf mg x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 391, :end-line 391, :max-fixed-arity 3, :fn-var true, :arglists (quote ([mf mg x])), :doc "Left-to-right composition of monads."}, filter {:protocol-inline nil, :meta {:file "/home/user/projects/imperative-nodejs/playground/out/cats/core.cljs", :line 323, :column 7, :end-line 323, :end-column 13, :arglists (quote ([p mv])), :doc "Applies a predicate to a value in a `MonadZero` instance,\n  returning the identity element when the predicate yields false.\n\n  Otherwise, returns the instance unchanged.\n\n      (require '[cats.monad.moaybe :as maybe])\n      (require '[cats.core :as m])\n\n      (m/filter (partial < 2) (maybe/just 3))\n      ;=> <Just [3]>\n\n      (m/filter (partial < 4) (maybe/just 3))\n      ;=> <Nothing>\n  "}, :name cats.core/filter, :variadic false, :file "out/cats/core.cljs", :end-column 13, :method-params ([p mv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 323, :end-line 323, :max-fixed-arity 2, :fn-var true, :arglists (quote ([p mv])), :doc "Applies a predicate to a value in a `MonadZero` instance,\n  returning the identity element when the predicate yields false.\n\n  Otherwise, returns the instance unchanged.\n\n      (require '[cats.monad.moaybe :as maybe])\n      (require '[cats.core :as m])\n\n      (m/filter (partial < 2) (maybe/just 3))\n      ;=> <Just [3]>\n\n      (m/filter (partial < 4) (maybe/just 3))\n      ;=> <Nothing>\n  "}, fmap {:protocol-inline nil, :meta {:file "/home/user/projects/imperative-nodejs/playground/out/cats/core.cljs", :line 156, :column 7, :end-line 156, :end-column 11, :arglists (quote ([f fv])), :doc "Apply a function f to the value inside functor's fv\n  preserving the context type."}, :name cats.core/fmap, :variadic false, :file "out/cats/core.cljs", :end-column 11, :method-params ([f fv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 156, :end-line 156, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f fv])), :doc "Apply a function f to the value inside functor's fv\n  preserving the context type."}, extract {:protocol-inline nil, :meta {:file "/home/user/projects/imperative-nodejs/playground/out/cats/core.cljs", :line 408, :column 7, :end-line 408, :end-column 14, :arglists (quote ([v])), :doc "Generic function for unwrap/extract\n  the inner value of a container."}, :name cats.core/extract, :variadic false, :file "out/cats/core.cljs", :end-column 14, :method-params ([v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 408, :end-line 408, :max-fixed-arity 1, :fn-var true, :arglists (quote ([v])), :doc "Generic function for unwrap/extract\n  the inner value of a container."}, sequence {:protocol-inline nil, :meta {:file "/home/user/projects/imperative-nodejs/playground/out/cats/core.cljs", :line 261, :column 7, :end-line 261, :end-column 15, :arglists (quote ([mvs])), :doc "Given a non-empty collection of monadic values, collect\n  their values in a vector returned in the monadic context.\n\n      (sequence [(maybe/just 2) (maybe/just 3)])\n      ;; => <Just [[2, 3]]>\n\n      (sequence [(maybe/nothing) (maybe/just 3)])\n      ;; => <Nothing>\n  "}, :name cats.core/sequence, :variadic false, :file "out/cats/core.cljs", :end-column 15, :method-params ([mvs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 261, :end-line 261, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mvs])), :doc "Given a non-empty collection of monadic values, collect\n  their values in a vector returned in the monadic context.\n\n      (sequence [(maybe/just 2) (maybe/just 3)])\n      ;; => <Just [[2, 3]]>\n\n      (sequence [(maybe/nothing) (maybe/just 3)])\n      ;; => <Nothing>\n  "}}, :require-macros {cats.core cats.core}, :cljs.analyzer/constants {:seen #{:else}, :order [:else]}, :doc "Category Theory abstractions for Clojure"}